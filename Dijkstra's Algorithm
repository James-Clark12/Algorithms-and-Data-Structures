
In statements - Dijkstra's Algorithm

const Dijkstra = (graph, firstVertex) => {
  
  // Initialise all needed variables
  // object where keys are vertex's and their values are the current min distnace found to get there
  const distances = {};
  // record of visitedVertices
  const visitedVertices = {};
  // Records which vertex (assigned as the value) led to another vertex (the key) to be relaxed to its current weight
  // thus allowing you to trace backwards from a vertex the shortest path to the beginning
  const previousVertices = {};
  // Min priority queue - used so can go to the smallest weight node first
  const queue = new PriorityQueue();

  // Init all distances with infinity assuming that currently we can't reach
  // any of the vertices except start one.
  graph.getAllVertices().forEach((vertex) => {
    distances[vertex.getKey()] = Infinity;
    previousVertices[vertex.getKey()] = null;
  });
  // first key has cost of 0 to reach - this is where we start from
  distances[startVertex.getKey()] = 0;

  // Init vertices queue.
  queue.add(startVertex, distances[startVertex.getKey()]);

  while (!queue.isEmpty()) {
    // take min from queue
    const currentVertex = queue.poll();

    // iterature through the values' neighbours
    graph.getNeighbors(currentVertex).forEach((neighbor) => {
      // Don't visit already visited vertices.
      if (!visitedVertices[neighbor.getKey()]) {
        // Update distances to every neighbor from current vertex.
        const edge = graph.findEdge(currentVertex, neighbor);

        const existingDistanceToNeighbor = distances[neighbor.getKey()];
        const distanceToNeighborFromCurrent = distances[currentVertex.getKey()] + edge.weight;

        // if there is now a shorter route to a neighbour
        if (distanceToNeighborFromCurrent < existingDistanceToNeighbor) {
          // Update the neighbours weight
          distances[neighbor.getKey()] = distanceToNeighborFromCurrent;

          // Change priority.
          if (queue.hasValue(neighbor)) {
            queue.changePriority(neighbor, distances[neighbor.getKey()]);
          }

          // Remember previous vertex.
          previousVertices[neighbor.getKey()] = currentVertex;
        }

        // Add neighbor to the queue for further visiting.
        if (!queue.hasValue(neighbor)) {
          queue.add(neighbor, distances[neighbor.getKey()]);
        }
      }
    });

    // Add current vertex to visited ones.
    visitedVertices[currentVertex.getKey()] = currentVertex;
  }

  return {
    distances,
    previousVertices,
  };
}
}
